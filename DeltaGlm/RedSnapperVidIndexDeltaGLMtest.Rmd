
Red Snapper Video Index Using Delta GLM
========


```{r prelim,echo=FALSE,message=FALSE, warning=FALSE,error=FALSE}
rm(list=ls(all=TRUE)) 
graphics.off()
windows(record=T)
setwd ("\\\\CCFHR-S-1534090\\popdyn1\\SEDAR\\SEDAR 41\\SEFISIndices")
library(MASS)
library(doBy)
library(statmod)
library(Hmisc)


#setup the dglm function
source("\\\\CCFHR-S-1534090\\popdyn1\\SEDAR\\SEDAR 41\\SEFISIndices\\DeltaGlm\\DeltaGLM-1-7-2-PBC-LGC.r")


```

```{r ReadData, echo=FALSE,message=FALSE, warning=FALSE,error=FALSE}
 # Read in Red Snapper Data
rs=read.csv("\\\\CCFHR-S-1534090\\popdyn1\\SEDAR\\SEDAR 41\\SEFISIndices\\RedSnapGLMData.csv")#;head(rs);rawdat=rs
```


```{r ConditionData, echo=FALSE,message=FALSE, warning=FALSE}
# Full data subsetting: 
rs <- rs[rs$Station_Type!="Recon",]                # remove recon stations
rs <- rs[rs$A.Video.Readable == "Yes",]         # remove invalid videos
rs <- subset(rs, rs$Start_Depth > 0)                  # remove NA in depth
rs <- subset(rs, rs$Start_Depth < 100)              # remove < 100 m deep
rs <- subset(rs, rs$LastOfTemp > 0)                 # remove blank water temps
rs <- subset(rs, rs$Turbidity != "Unknown")    # remove unknown turbidity values

#Eliminate unnecessary columns
dat=subset(rs,select=c(MC_Lutjanus.campechanus,Year,Turbidity,Current_Direction,Current_Magnitude,Substrate_Cat,
                       Relief,Size,Biotic_Density_Cat,Biotic_Type,Biotic_Height,Start_Depth,Julian,Start_Latitude,LastOfTemp,TOD))
names(dat)=c('cpue',names(dat)[-1])#;head(dat)
orgnames=names(dat)

#Now add in the presence field
#temp=rep(1.0,dim(dat)[1])
#temp[is.na(dat$cpue)]=0
#dat=cbind(dat,temp)

#rename to short names
#names(dat)=c('cpue','y','wc','cd','cm','sc','sr','ss','bd','bt','bh','d','t','lat','temp','tod','pos')#;head(dat)
names(dat)=c('cpue','y','wc','cd','cm','sc','sr','ss','bd','bt','bh','d','t','lat','temp','tod')#;head(dat)

#replace NA in the cpue with 0
dat$cpue[is.na(dat$cpue)]=0

#now categorize the continuous variables
#depth
hist(dat$d,breaks=seq(10,110,by=5))
summary(dat$d)
#temp=cut(dat$d,breaks=c(14,25,41,52,115),labels=FALSE)#;temp;table(temp)
#temp=cut(dat$d,2,breaks=c(0,as.numeric(summary(dat$d))[-c(1,4)]),labels=FALSE);temp;table(temp)
temp=cut(dat$d,2,breaks=quantile(dat$d),labels=FALSE)#;temp;table(temp)
dat$d=temp

#latitude
hist(dat$lat,breaks=seq(27,36,by=0.25))
summary(dat$lat)
#temp=cut(dat$lat,breaks=c(27,29.75,31.25,32.75,34,35.25),labels=FALSE)#;temp;table(temp)
#temp=cut(dat$lat,2,breaks=c(0,as.numeric(summary(dat$lat))[-c(1,4)]),labels=FALSE);temp;table(temp)
temp=cut(dat$lat,2,breaks=quantile(dat$lat),labels=FALSE)#;temp;table(temp)
dat$lat=temp

#day of year (t)
hist(dat$t,breaks=seq(110,305,by=5))
summary(dat$t)
#temp=cut(dat$t,breaks=c(##,##,##,##,##,##),labels=FALSE)#;temp;table(temp)
#temp=cut(dat$t,2,breaks=c(0,as.numeric(summary(dat$t))[-c(1,4)]),labels=FALSE);temp;table(temp)
temp=cut(dat$t,2,breaks=quantile(dat$t),labels=FALSE)#;temp;table(temp)
dat$t=temp

#water temperature (temp)
hist(dat$temp,breaks=seq(12.25,29.25,by=0.25))
summary(dat$temp)
#temp=cut(dat$t,breaks=c(##,##,##,##,##,##),labels=FALSE)#;temp;table(temp)
#temp=cut(dat$temp,2,breaks=c(0,as.numeric(summary(dat$temp))[-c(1,4)]),labels=FALSE);temp;table(temp)
temp=cut(dat$temp,2,breaks=quantile(dat$temp),labels=FALSE)#;temp;table(temp)
dat$temp=temp

#time of day (tod)
hist(dat$tod,breaks=seq(0.4,0.95,by=0.025))
summary(dat$tod)
#temp=cut(dat$tod,breaks=c(##,##,##,##,##,##),labels=FALSE)#;temp;table(temp)
#temp=cut(dat$tod,2,breaks=c(0,as.numeric(summary(dat$tod))[-c(1,4)]),labels=FALSE);temp;table(temp)
temp=cut(dat$tod,2,breaks=quantile(dat$tod),labels=FALSE)#;temp;table(temp)
dat$tod=temp

#Factorize variables
dat$y=factor(dat$y)
dat$d=factor(dat$d)
dat$lat=factor(dat$lat)
dat$t=factor(dat$t)
dat$temp=factor(dat$temp)
dat$tod=factor(dat$tod)


#head(dat)



```

**So this bit allows variable selection of each of the model types**


```{r VariableScreening, echo=FALSE,message=FALSE, warning=FALSE,error=FALSE}
#In below, AIC values cannot be used to discrimate between error structures, bc R excludes the normalizing constant
dat.pos=dat[dat$cpue>0,]
dat.bin=dat; dat.bin$cpue[dat$cpue>0]=1.0

par(mfcol=c(2,2))
pos.ln.start<-glm(log(cpue)~y+wc+cd+cm+sc+sr+ss+bd+bt+bh+d+t+lat+temp+tod, data=dat.pos, family=gaussian(link="identity"))
  glm.step <- stepAIC(pos.ln.start,direction="backward")
  pos.ln.fit=glm.step
  #plot(pos.ln.fit)
pos.gamma.start<-glm(cpue~y+wc+cd+cm+sc+sr+ss+bd+bt+bh+d+t+lat+temp+tod, data=dat.pos, family=Gamma(link="log"))
  glm.step <- stepAIC(pos.gamma.start,direction="backward")
  pos.gamma.fit=glm.step
bin.start<-glm(cpue~y+wc+cd+cm+sc+sr+ss+bd+bt+bh+d+t+lat+temp+tod, data=dat.bin, family="binomial")
  glm.step <- stepAIC(bin.start,direction="backward")
  bin.fit1=glm.step
  #qr.bin=qres.binom(bin.fit1)
  #qqnorm(qr.bin,main='QQplot residuals (binomial)',  cex=0.5)
  #qqline(qr.bin)

par(mfcol=c(1,1))

preds=exp(fitted(pos.ln.start))
cbind(preds,dat.pos$cpue,log(dat.pos$cpue)-predict(pos.ln.start),residuals(pos.ln.start))
plot(preds,dat.pos$cpue)
abline(a=0,b=1)
plot(fitted(pos.ln.start),log(dat.pos$cpue))
abline(a=0,b=1)

hist(dat.pos$cpue,breaks=seq(0,5.5,by=.05),freq=T,right=TRUE,xlab='Aggregate Fish Counted', main='lognposglm GLM')  
d=hist(preds,breaks=seq(0,5.5,by=.05),plot=FALSE)
lines(d$mids,d$counts, col="blue",type='l')      
hist(log(dat.pos$cpue),breaks=seq(-4,1.75,by=.05),freq=T,right=TRUE,xlab='Aggregate Fish Counted', main='lognposglm GLM')  
d=hist(fitted(pos.ln.start),breaks=seq(-4,1.75,by=.05),plot=FALSE)
lines(d$mids,d$counts, col="blue",type='l')      


```
